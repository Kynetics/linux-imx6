/*
 * Copyright (C) 2014 Revolution Robotics, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <mach/iomux-mx6sl.h>

//#define WARP_REV1P10 1

#ifndef _BOARD_MX6SL_WARP_H
#define _BOARD_MX6SL_WARP_H

#define MURATA_BLUETOOTH_ENABLE

// PMIC
#define MX6_GPIO_PMIC_IRQ       IMX_GPIO_NR(3, 22)
// SPI for Accelerometer
#define MX6_BRD_ECSPI2_CS0	IMX_GPIO_NR(4, 15)	// ECSPI2_SS0

// GPIO for WL
#define WARP_WL_REG_ON			IMX_GPIO_NR(4, 5)
#define WARP_GPIO0_WL_HOSTWAKE		IMX_GPIO_NR(4, 7)
// GPIO for BT
#ifdef WARP_REV1P10
	#define WARP_BT_RST_N			IMX_GPIO_NR(4, 6)
	#define WARP_BT_REG_ON			IMX_GPIO_NR(3, 28)
	#define WARP_BT_GPIO1_HOSTWAKE		IMX_GPIO_NR(4, 2)
	#define WARP_BT_GPIO1_BTWAKE		IMX_GPIO_NR(4, 4)
#else
	#define WARP_BT_REG_ON			IMX_GPIO_NR(3, 25)
	#define WARP_BT_GPIO1_HOSTWAKE		IMX_GPIO_NR(3, 27)
	#define WARP_BT_GPIO1_BTWAKE		IMX_GPIO_NR(4, 4)
	#define WARP_BT_RST_N			IMX_GPIO_NR(4, 6)
#endif

// LH154 LCD
#  define LCDIF_PIXCLK_FREQ	24000000
#  define LCDIF_SLOW_FREQDIV	250
#  define LCDIF_FAST_FREQDIV	1
#  define LCDIF_BUS_WIDTH	8
#  define SSD2805_PLL_CLK_FREQ	200000000

#define MIPI_CLK_FREQ		12000000

#define ELCDIF_PHY_BASE_ADDR 0x020f8000

#define MX6_BRD_ECSPI1_CS0	IMX_GPIO_NR(4, 11)	/* ECSPI1_SS0 */
#define MX6_BRD_SD2_WP		IMX_GPIO_NR(4, 29)	/* SD2_DAT6 */
#define MX6_BRD_SD2_CD		IMX_GPIO_NR(5, 0)	/* SD2_DAT7 */

// LCD Interface GPIO definitions for GPIO CMD read mode
#define PINID_LCD_DAT0		IMX_GPIO_NR(2, 20)
#define PINID_LCD_DAT1		IMX_GPIO_NR(2, 21)
#define PINID_LCD_DAT2		IMX_GPIO_NR(2, 22)
#define PINID_LCD_DAT3		IMX_GPIO_NR(2, 23)
#define PINID_LCD_DAT4		IMX_GPIO_NR(2, 24)
#define PINID_LCD_DAT5		IMX_GPIO_NR(2, 25)
#define PINID_LCD_DAT6		IMX_GPIO_NR(2, 26)
#define PINID_LCD_DAT7		IMX_GPIO_NR(2, 27)
#define PINID_LCD_DAT8		IMX_GPIO_NR(2, 28)
#define PINID_LCD_DAT9		IMX_GPIO_NR(2, 29)
#define PINID_LCD_DAT10		IMX_GPIO_NR(2, 30)
#define PINID_LCD_DAT11		IMX_GPIO_NR(2, 31)
#define PINID_LCD_DAT12		IMX_GPIO_NR(3, 0)
#define PINID_LCD_DAT13		IMX_GPIO_NR(3, 1)
#define PINID_LCD_DAT14		IMX_GPIO_NR(3, 2)
#define PINID_LCD_DAT15		IMX_GPIO_NR(3, 3)

#define PINID_LCD_CS		IMX_GPIO_NR(2, 17)
#define PINID_LCD_WR		IMX_GPIO_NR(2, 15)

#define PINID_MIPI_TE		IMX_GPIO_NR(3, 4)
#define PINID_LCD_RSTN 		IMX_GPIO_NR(3, 7)
#define PINID_LCD_INTN		IMX_GPIO_NR(3, 8)
#define PINID_MIPI_BSYNC	IMX_GPIO_NR(3, 9)

#ifdef WARP_REV1P10
#define PINID_LCD_RS		IMX_GPIO_NR(2, 19)
#define PINID_LCD_RD		IMX_GPIO_NR(3, 11)
#define PINID_MIPI_RSTN		IMX_GPIO_NR(3, 10)
#else
#define PINID_LCD_RS		IMX_GPIO_NR(2, 18)
#define PINID_LCD_RD		IMX_GPIO_NR(2, 16)
#define PINID_MIPI_RSTN		IMX_GPIO_NR(3, 5)
#endif

// WaRP Specific PAD_CTRL Definitions
#define MX6SL_PWM_PAD_CTRL    ( PAD_CTL_SPEED_HIGH | PAD_CTL_DSE_80ohm |    \
                PAD_CTL_SRE_FAST | PAD_CTL_LVE)

#define	WARP_LCD_PAD_CTRL    ( PAD_CTL_SPEED_HIGH | PAD_CTL_DSE_80ohm |    \
                PAD_CTL_SRE_FAST | PAD_CTL_LVE)

#define	WARP_GPIO_PAD_CTRL ( PAD_CTL_SPEED_HIGH | PAD_CTL_DSE_80ohm |	\
                PAD_CTL_SRE_FAST | PAD_CTL_HYS | PAD_CTL_LVE)

#define WARP_I2C_PAD_CTRL_3V ( PAD_CTL_PKE | PAD_CTL_PUE   |	\
		PAD_CTL_PUS_22K_UP | PAD_CTL_SPEED_MED |		\
		PAD_CTL_DSE_34ohm   | PAD_CTL_SRE_FAST  |	\
		PAD_CTL_HYS         | PAD_CTL_ODE)

#define WARP_I2C_PAD_CTRL (PAD_CTL_LVE | PAD_CTL_PKE | PAD_CTL_PUE   |	\
		PAD_CTL_PUS_22K_UP | PAD_CTL_SPEED_MED |		\
		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  |		\
		PAD_CTL_HYS         | PAD_CTL_ODE)

#define	WARP_GPIO_PAD_CTRL_3V ( PAD_CTL_SPEED_HIGH | PAD_CTL_DSE_80ohm |	\
                PAD_CTL_SRE_FAST | PAD_CTL_HYS)

#define BBI2C_PAD_CTRL   (PAD_CTL_PUS_22K_UP |  PAD_CTL_PUE | PAD_CTL_PKE |	\
	PAD_CTL_SPEED_MED | PAD_CTL_DSE_80ohm | PAD_CTL_HYS |			\
	PAD_CTL_ODE | PAD_CTL_SRE_FAST)

#define MX6SL_UART_PAD_CTRL_PULLDOWN_SDK (PAD_CTL_LVE | PAD_CTL_PKE | PAD_CTL_PUE  |	\
		PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |		\
		PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)

//#define PINID_FT5X06_INT       IMX_GPIO_NR(3, 31) // ALT pads for touchscreen with off-board connector
#define PINID_FT5X06_INT	IMX_GPIO_NR(2, 12)

static iomux_v3_cfg_t warp_brd_pads[] = {

	MX6SL_PAD_UART1_RXD__UART1_RXD,
	MX6SL_PAD_UART1_TXD__UART1_TXD,

	MX6SL_PAD_SD2_CLK__USDHC2_CLK_50MHZ,
	MX6SL_PAD_SD2_CMD__USDHC2_CMD_50MHZ,
	MX6SL_PAD_SD2_DAT0__USDHC2_DAT0_50MHZ,
	MX6SL_PAD_SD2_DAT1__USDHC2_DAT1_50MHZ,
	MX6SL_PAD_SD2_DAT2__USDHC2_DAT2_50MHZ,
	MX6SL_PAD_SD2_DAT3__USDHC2_DAT3_50MHZ,
	MX6SL_PAD_SD2_DAT4__USDHC2_DAT4_50MHZ,
	MX6SL_PAD_SD2_DAT5__USDHC2_DAT5_50MHZ,
	MX6SL_PAD_SD2_DAT6__USDHC2_DAT6_50MHZ,
	MX6SL_PAD_SD2_DAT7__USDHC2_DAT7_50MHZ,
	MX6SL_PAD_SD2_RST__USDHC2_RST,

	MX6SL_PAD_SD3_CLK__USDHC3_CLK_50MHZ,
	MX6SL_PAD_SD3_CMD__USDHC3_CMD_50MHZ,
	MX6SL_PAD_SD3_DAT0__USDHC3_DAT0_50MHZ,
	MX6SL_PAD_SD3_DAT1__USDHC3_DAT1_50MHZ,
	MX6SL_PAD_SD3_DAT2__USDHC3_DAT2_50MHZ,
	MX6SL_PAD_SD3_DAT3__USDHC3_DAT3_50MHZ,

	/* Murata LBEH17YSHC GPIO */
	MX6SL_PAD_KEY_ROW6__GPIO_4_5,	// WL_REG_ON
	MX6SL_PAD_KEY_ROW7__GPIO_4_7,	// GPIO0_WL_HOSTWAKE
#ifdef WARP_REV1P10
	NEW_PAD_CTRL(MX6SL_PAD_KEY_COL2__GPIO_3_28,	WARP_GPIO_PAD_CTRL),	// BT_REG_ON
	NEW_PAD_CTRL(MX6SL_PAD_KEY_COL5__GPIO_4_2,	WARP_GPIO_PAD_CTRL),	// BT_GPIO1_HOSTWAKE
	NEW_PAD_CTRL(MX6SL_PAD_KEY_COL6__GPIO_4_4,	WARP_GPIO_PAD_CTRL),	// BT_GPIO1_BTWAKE
	NEW_PAD_CTRL(MX6SL_PAD_KEY_COL7__GPIO_4_6,	WARP_GPIO_PAD_CTRL),	// BT_RST_N
#else
	NEW_PAD_CTRL(MX6SL_PAD_KEY_ROW0__GPIO_3_25,	WARP_GPIO_PAD_CTRL),	// BT_REG_ON
	NEW_PAD_CTRL(MX6SL_PAD_KEY_ROW1__GPIO_3_27,	WARP_GPIO_PAD_CTRL),	// BT_GPIO1_HOSTWAKE
	NEW_PAD_CTRL(MX6SL_PAD_KEY_COL6__GPIO_4_4,	WARP_GPIO_PAD_CTRL),	// BT_GPIO1_BTWAKE
	NEW_PAD_CTRL(MX6SL_PAD_KEY_COL7__GPIO_4_6,	WARP_GPIO_PAD_CTRL),	// BT_RST_N
#endif

	/* I2C */
	MX6SL_PAD_I2C1_SCL__I2C1_SCL,
	MX6SL_PAD_I2C1_SDA__I2C1_SDA,

	/* ECSPI2 */
	MX6SL_PAD_ECSPI2_MISO__ECSPI2_MISO,
	MX6SL_PAD_ECSPI2_MOSI__ECSPI2_MOSI,
	MX6SL_PAD_ECSPI2_SCLK__ECSPI2_SCLK,
	MX6SL_PAD_ECSPI2_SS0__GPIO_4_15,	/* SS0 */

// ALT pads for touchscreen with off-board connector on 1.0d boards
//	NEW_PAD_CTRL(MX6SL_PAD_AUD_RXC__I2C3_SDA,	WARP_I2C_PAD_CTRL_3V),
//	NEW_PAD_CTRL(MX6SL_PAD_AUD_RXFS__I2C3_SCL,	WARP_I2C_PAD_CTRL_3V),
//	NEW_PAD_CTRL(MX6SL_PAD_AUD_TXC__GPIO_1_3,	WARP_I2C_PAD_CTRL_3V),
//	NEW_PAD_CTRL(MX6SL_PAD_KEY_ROW3__GPIO_3_31,     WARP_GPIO_PAD_CTRL_3V),

	NEW_PAD_CTRL(MX6SL_PAD_I2C2_SDA__I2C2_SDA,	WARP_I2C_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_I2C2_SCL__I2C2_SCL,	WARP_I2C_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_EPDC_PWRINT__GPIO_2_12,	WARP_GPIO_PAD_CTRL),
#ifdef WARP_REV1P10
	NEW_PAD_CTRL(MX6SL_PAD_AUD_RXD__GPIO_1_2,WARP_I2C_PAD_CTRL),  // CTRL_EVENT
	NEW_PAD_CTRL(MX6SL_PAD_AUD_TXC__GPIO_1_3,WARP_I2C_PAD_CTRL),  //CTRL_WAKE
	NEW_PAD_CTRL(MX6SL_PAD_AUD_TXFS__GPIO_1_4,WARP_I2C_PAD_CTRL), //CTRL_PB2
#else
	NEW_PAD_CTRL(MX6SL_PAD_SD1_DAT0__GPIO_5_11,WARP_I2C_PAD_CTRL),// CTRL_EVENT
	NEW_PAD_CTRL(MX6SL_PAD_SD1_CMD__GPIO_5_14,WARP_I2C_PAD_CTRL), //CTRL_WAKE
	NEW_PAD_CTRL(MX6SL_PAD_SD1_CLK__GPIO_5_15,WARP_I2C_PAD_CTRL), //CTRL_PB2
#endif

	NEW_PAD_CTRL(MX6SL_PAD_REF_CLK_32K__GPIO_3_22, WARP_GPIO_PAD_CTRL), // PMIC_IRQ#

	// PWM OUTPUT
	NEW_PAD_CTRL(MX6SL_PAD_AUD_MCLK__PWM4_PWMO, MX6SL_PWM_PAD_CTRL),    // LCD_CLK

	// SYSTEM80/MPU8080 Interface to SSD2805C
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT0__LCDIF_DAT_0,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT1__LCDIF_DAT_1,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT2__LCDIF_DAT_2,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT3__LCDIF_DAT_3,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT4__LCDIF_DAT_4,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT5__LCDIF_DAT_5,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT6__LCDIF_DAT_6,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT7__LCDIF_DAT_7,	WARP_LCD_PAD_CTRL),
#if (LCDIF_BUS_WIDTH == 16)
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT8__LCDIF_DAT_8,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT9__LCDIF_DAT_9,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT10__LCDIF_DAT_10,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT11__LCDIF_DAT_11,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT12__LCDIF_DAT_12,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT13__LCDIF_DAT_13,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT14__LCDIF_DAT_14,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT15__LCDIF_DAT_15,	WARP_LCD_PAD_CTRL),
#endif
	NEW_PAD_CTRL(MX6SL_PAD_LCD_CLK__LCDIF_WR_RWN,	WARP_LCD_PAD_CTRL), // LCD_WRX(SSD)/LCD_WR_RWn(MX6)
	NEW_PAD_CTRL(MX6SL_PAD_LCD_HSYNC__LCDIF_CS,	WARP_LCD_PAD_CTRL), // LCD_CSX(SSD)/LCD_CS(MX6)
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT16__GPIO_3_4,	WARP_LCD_PAD_CTRL), // MIPI_TE
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT19__GPIO_3_7,	WARP_LCD_PAD_CTRL), // LCD_RSTn
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT20__GPIO_3_8,	WARP_LCD_PAD_CTRL), // LCD_INTn
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT21__GPIO_3_9,	WARP_LCD_PAD_CTRL), // MIPI_B_SYNC
#ifdef WARP_REV1P10
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT22__GPIO_3_10,    WARP_LCD_PAD_CTRL), // MIPI_RSTn
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT23__GPIO_3_11,    WARP_LCD_PAD_CTRL), // LCD_RDX(SSD)/LCD_RD_E(MX6)
	NEW_PAD_CTRL(MX6SL_PAD_LCD_RESET__GPIO_2_19,    WARP_LCD_PAD_CTRL), // LCD_DCX(SSD) LCD_RS(MX6)
#else
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT17__GPIO_3_5,     WARP_LCD_PAD_CTRL), // MIPI_RSTn
	NEW_PAD_CTRL(MX6SL_PAD_LCD_ENABLE__GPIO_2_16,   WARP_LCD_PAD_CTRL), // LCD_RDX(SSD)/LCD_RD_E(MX6)
	NEW_PAD_CTRL(MX6SL_PAD_LCD_VSYNC__GPIO_2_18,    WARP_LCD_PAD_CTRL), // LCD_DCX(SSD) LCD_RS(MX6)
#endif
};

#ifdef MURATA_BLUETOOTH_ENABLE
#ifdef WARP_REV1P10
static iomux_v3_cfg_t mx6sl_uart2_pads[] = {
	NEW_PAD_CTRL(MX6SL_PAD_EPDC_D12__UART2_RXD, MX6SL_UART_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_EPDC_D13__UART2_TXD, MX6SL_UART_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_EPDC_D14__UART2_RTS, MX6SL_UART_PAD_CTRL_PULLDOWN_SDK),
	NEW_PAD_CTRL(MX6SL_PAD_EPDC_D15__UART2_CTS, MX6SL_UART_PAD_CTRL_PULLDOWN_SDK),
};
#else
static iomux_v3_cfg_t mx6sl_uart5_pads[] = {
	NEW_PAD_CTRL(MX6SL_PAD_ECSPI1_MOSI__UART5_TXD, MX6SL_UART_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_ECSPI1_SCLK__UART5_RXD, MX6SL_UART_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_ECSPI1_MISO__UART5_RTS, MX6SL_UART_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_ECSPI1_SS0__UART5_CTS, MX6SL_UART_PAD_CTRL),
};
#endif

#endif /* MURATA_BLUETOOTH_ENABLE */

static iomux_v3_cfg_t mx6sl_uart3_pads[] = {
	NEW_PAD_CTRL(MX6SL_PAD_AUD_RXC__UART3_TXD, MX6SL_UART_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_AUD_RXFS__UART3_RXD, MX6SL_UART_PAD_CTRL),
};

#ifdef LCDIF_GPIO_READ
// Pad definitions to switch between GPIO Read and normal LCDIF interface mode
static iomux_v3_cfg_t mcu8080display_pads[] = {
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT0__LCDIF_DAT_0, 	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT1__LCDIF_DAT_1, 	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT2__LCDIF_DAT_2, 	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT3__LCDIF_DAT_3, 	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT4__LCDIF_DAT_4, 	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT5__LCDIF_DAT_5, 	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT6__LCDIF_DAT_6, 	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT7__LCDIF_DAT_7, 	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT8__LCDIF_DAT_8, 	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT9__LCDIF_DAT_9,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT10__LCDIF_DAT_10,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT11__LCDIF_DAT_11,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT12__LCDIF_DAT_12,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT13__LCDIF_DAT_13,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT14__LCDIF_DAT_14,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT15__LCDIF_DAT_15,	WARP_LCD_PAD_CTRL),

	NEW_PAD_CTRL(MX6SL_PAD_LCD_CLK__LCDIF_WR_RWN,	WARP_LCD_PAD_CTRL), // LCD_WRX(SSD)/LCD_WR_RWn(MX6_Signal)/
	NEW_PAD_CTRL(MX6SL_PAD_LCD_HSYNC__LCDIF_CS, 	WARP_LCD_PAD_CTRL), // LCD_CSX(SSD)/LCD_CS(MX6_Signal)
	NEW_PAD_CTRL(MX6SL_PAD_AUD_TXFS__PWM3_PWMO, 	WARP_LCD_PAD_CTRL), // temp pwm output test to pad
//	NEW_PAD_CTRL(MX6SL_PAD_AUD_TXFS__GPIO_1_4,  	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_AUD_MCLK__PWM4_PWMO, 	WARP_LCD_PAD_CTRL), // LCD_CLK
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT16__GPIO_3_4, 	WARP_LCD_PAD_CTRL), // MIPI_TE
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT19__GPIO_3_7, 	WARP_LCD_PAD_CTRL), // LCD_RSTn
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT20__GPIO_3_8, 	WARP_LCD_PAD_CTRL), // LCD_INTn
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT21__GPIO_3_9, 	WARP_LCD_PAD_CTRL), // MIPI_B_SYNC
#ifdef WARP_REV1P10
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT22__GPIO_3_10,    WARP_LCD_PAD_CTRL), // MIPI_RSTn
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT23__GPIO_3_11,    WARP_LCD_PAD_CTRL), // LCD_RDX(SSD)/LCD_RD_E(MX6)
	NEW_PAD_CTRL(MX6SL_PAD_LCD_RESET__GPIO_2_19,    WARP_LCD_PAD_CTRL), // LCD_DCX(SSD) LCD_RS(MX6)
#else
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT17__GPIO_3_5,     WARP_LCD_PAD_CTRL), // MIPI_RSTn
	NEW_PAD_CTRL(MX6SL_PAD_LCD_ENABLE__GPIO_2_16,   WARP_LCD_PAD_CTRL), // LCD_RDX(SSD)/LCD_RD_E(MX6)
	NEW_PAD_CTRL(MX6SL_PAD_LCD_VSYNC__GPIO_2_18,    WARP_LCD_PAD_CTRL), // LCD_DCX(SSD) LCD_RS(MX6)
#endif
};

static iomux_v3_cfg_t mcu8080display_gpio_pads[] = {
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT0__GPIO_2_20,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT1__GPIO_2_21,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT2__GPIO_2_22,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT3__GPIO_2_23,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT4__GPIO_2_24,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT5__GPIO_2_25,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT6__GPIO_2_26,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT7__GPIO_2_27,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT8__GPIO_2_28,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT9__GPIO_2_29,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT10__GPIO_2_30,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT11__GPIO_2_31,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT12__GPIO_3_0,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT13__GPIO_3_1,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT14__GPIO_3_2,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT15__GPIO_3_3,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_LCD_CLK__GPIO_2_15,	WARP_LCD_PAD_CTRL), // LCD_WRX(SSD)/LCD_WR_RWn(MX6_Signal)/
	NEW_PAD_CTRL(MX6SL_PAD_LCD_HSYNC__GPIO_2_17,	WARP_LCD_PAD_CTRL), // LCD_CSX(SSD)/LCD_CS(MX6_Signal)
//	NEW_PAD_CTRL(MX6SL_PAD_AUD_TXFS__PWM3_PWMO,	WARP_LCD_PAD_CTRL), // temp pwm output test to pad
//	NEW_PAD_CTRL(MX6SL_PAD_AUD_TXFS__GPIO_1_4,	WARP_LCD_PAD_CTRL),
	NEW_PAD_CTRL(MX6SL_PAD_AUD_MCLK__PWM4_PWMO,	WARP_LCD_PAD_CTRL), // LCD_CLK
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT16__GPIO_3_4,	WARP_LCD_PAD_CTRL), // MIPI_TE
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT19__GPIO_3_7,	WARP_LCD_PAD_CTRL), // LCD_RSTn
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT20__GPIO_3_8,	WARP_LCD_PAD_CTRL), // LCD_INTn
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT21__GPIO_3_9,	WARP_LCD_PAD_CTRL), // MIPI_B_SYNC
#ifdef WARP_REV1P10
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT22__GPIO_3_10,    WARP_LCD_PAD_CTRL), // MIPI_RSTn
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT23__GPIO_3_11,    WARP_LCD_PAD_CTRL), // LCD_RDX(SSD)/LCD_RD_E(MX6)
	NEW_PAD_CTRL(MX6SL_PAD_LCD_RESET__GPIO_2_19,    WARP_LCD_PAD_CTRL), // LCD_DCX(SSD) LCD_RS(MX6)
#else
	NEW_PAD_CTRL(MX6SL_PAD_LCD_DAT17__GPIO_3_5,     WARP_LCD_PAD_CTRL), // MIPI_RSTn
	NEW_PAD_CTRL(MX6SL_PAD_LCD_ENABLE__GPIO_2_16,   WARP_LCD_PAD_CTRL), // LCD_RDX(SSD)/LCD_RD_E(MX6)
	NEW_PAD_CTRL(MX6SL_PAD_LCD_VSYNC__GPIO_2_18,    WARP_LCD_PAD_CTRL), // LCD_DCX(SSD) LCD_RS(MX6)
#endif
};
#endif
// End GPIO Read pad definitions

static iomux_v3_cfg_t warp_suspend_enter_pads[] = {
};

static iomux_v3_cfg_t warp_suspend_exit_pads[] = {
};

#define MX6SL_USDHC_8BIT_PAD_SETTING(id, speed)	\
mx6sl_sd##id##_##speed##mhz[] = {		\
	MX6SL_PAD_SD##id##_CLK__USDHC##id##_CLK_##speed##MHZ,	\
	MX6SL_PAD_SD##id##_CMD__USDHC##id##_CMD_##speed##MHZ,	\
	MX6SL_PAD_SD##id##_DAT0__USDHC##id##_DAT0_##speed##MHZ,	\
	MX6SL_PAD_SD##id##_DAT1__USDHC##id##_DAT1_##speed##MHZ,	\
	MX6SL_PAD_SD##id##_DAT2__USDHC##id##_DAT2_##speed##MHZ,	\
	MX6SL_PAD_SD##id##_DAT3__USDHC##id##_DAT3_##speed##MHZ,	\
	MX6SL_PAD_SD##id##_DAT4__USDHC##id##_DAT4_##speed##MHZ,	\
	MX6SL_PAD_SD##id##_DAT5__USDHC##id##_DAT5_##speed##MHZ,	\
	MX6SL_PAD_SD##id##_DAT6__USDHC##id##_DAT6_##speed##MHZ,	\
	MX6SL_PAD_SD##id##_DAT7__USDHC##id##_DAT7_##speed##MHZ,	\
}
#define MX6SL_USDHC_4BIT_PAD_SETTING(id, speed)	\
mx6sl_sd##id##_##speed##mhz[] = {		\
	MX6SL_PAD_SD##id##_CLK__USDHC##id##_CLK_##speed##MHZ,	\
	MX6SL_PAD_SD##id##_CMD__USDHC##id##_CMD_##speed##MHZ,	\
	MX6SL_PAD_SD##id##_DAT0__USDHC##id##_DAT0_##speed##MHZ,	\
	MX6SL_PAD_SD##id##_DAT1__USDHC##id##_DAT1_##speed##MHZ,	\
	MX6SL_PAD_SD##id##_DAT2__USDHC##id##_DAT2_##speed##MHZ,	\
	MX6SL_PAD_SD##id##_DAT3__USDHC##id##_DAT3_##speed##MHZ,	\
}

static iomux_v3_cfg_t MX6SL_USDHC_8BIT_PAD_SETTING(1, 50);
static iomux_v3_cfg_t MX6SL_USDHC_8BIT_PAD_SETTING(1, 100);
static iomux_v3_cfg_t MX6SL_USDHC_8BIT_PAD_SETTING(1, 200);
static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(2, 50);
static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(2, 100);
static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(2, 200);
static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(3, 50);
static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(3, 100);
static iomux_v3_cfg_t MX6SL_USDHC_4BIT_PAD_SETTING(3, 200);

#endif
